{"id":"../node_modules/near-api-js/src/utils/key_pair.ts","dependencies":[{"name":"C:\\users\\htafo\\dev\\near\\staking-tools\\node_modules\\near-api-js\\tsconfig.json","includedInParent":true,"mtime":1602709694358},{"name":"C:\\users\\htafo\\dev\\near\\staking-tools\\package.json","includedInParent":true,"mtime":1602792924775},{"name":"C:\\users\\htafo\\dev\\near\\staking-tools\\node_modules\\near-api-js\\package.json","includedInParent":true,"mtime":1602709694358},{"name":"tweetnacl","loc":{"line":7,"column":44},"parent":"C:\\users\\htafo\\dev\\near\\staking-tools\\node_modules\\near-api-js\\src\\utils\\key_pair.ts","resolved":"C:\\users\\htafo\\dev\\near\\staking-tools\\node_modules\\tweetnacl\\nacl-fast.js"},{"name":"./serialize","loc":{"line":8,"column":28},"parent":"C:\\users\\htafo\\dev\\near\\staking-tools\\node_modules\\near-api-js\\src\\utils\\key_pair.ts","resolved":"C:\\users\\htafo\\dev\\near\\staking-tools\\node_modules\\near-api-js\\src\\utils\\serialize.ts"},{"name":"./enums","loc":{"line":9,"column":24},"parent":"C:\\users\\htafo\\dev\\near\\staking-tools\\node_modules\\near-api-js\\src\\utils\\key_pair.ts","resolved":"C:\\users\\htafo\\dev\\near\\staking-tools\\node_modules\\near-api-js\\src\\utils\\enums.ts"}],"generated":{"js":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.KeyType = void 0;\r\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\r\nconst serialize_1 = require(\"./serialize\");\r\nconst enums_1 = require(\"./enums\");\r\n/** All supported key types */\r\nvar KeyType;\r\n(function (KeyType) {\r\n    KeyType[KeyType[\"ED25519\"] = 0] = \"ED25519\";\r\n})(KeyType = exports.KeyType || (exports.KeyType = {}));\r\nfunction key_type_to_str(keyType) {\r\n    switch (keyType) {\r\n        case KeyType.ED25519: return 'ed25519';\r\n        default: throw new Error(`Unknown key type ${keyType}`);\r\n    }\r\n}\r\nfunction str_to_key_type(keyType) {\r\n    switch (keyType.toLowerCase()) {\r\n        case 'ed25519': return KeyType.ED25519;\r\n        default: throw new Error(`Unknown key type ${keyType}`);\r\n    }\r\n}\r\n/**\r\n * PublicKey representation that has type and bytes of the key.\r\n */\r\nclass PublicKey extends enums_1.Assignable {\r\n    static from(value) {\r\n        if (typeof value === 'string') {\r\n            return PublicKey.fromString(value);\r\n        }\r\n        return value;\r\n    }\r\n    static fromString(encodedKey) {\r\n        const parts = encodedKey.split(':');\r\n        if (parts.length === 1) {\r\n            return new PublicKey({ keyType: KeyType.ED25519, data: serialize_1.base_decode(parts[0]) });\r\n        }\r\n        else if (parts.length === 2) {\r\n            return new PublicKey({ keyType: str_to_key_type(parts[0]), data: serialize_1.base_decode(parts[1]) });\r\n        }\r\n        else {\r\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\r\n        }\r\n    }\r\n    toString() {\r\n        return `${key_type_to_str(this.keyType)}:${serialize_1.base_encode(this.data)}`;\r\n    }\r\n}\r\nexports.PublicKey = PublicKey;\r\nclass KeyPair {\r\n    /**\r\n     * @param curve Name of elliptical curve, case-insensitive\r\n     * @returns Random KeyPair based on the curve\r\n     */\r\n    static fromRandom(curve) {\r\n        switch (curve.toUpperCase()) {\r\n            case 'ED25519': return KeyPairEd25519.fromRandom();\r\n            default: throw new Error(`Unknown curve ${curve}`);\r\n        }\r\n    }\r\n    static fromString(encodedKey) {\r\n        const parts = encodedKey.split(':');\r\n        if (parts.length === 1) {\r\n            return new KeyPairEd25519(parts[0]);\r\n        }\r\n        else if (parts.length === 2) {\r\n            switch (parts[0].toUpperCase()) {\r\n                case 'ED25519': return new KeyPairEd25519(parts[1]);\r\n                default: throw new Error(`Unknown curve: ${parts[0]}`);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\r\n        }\r\n    }\r\n}\r\nexports.KeyPair = KeyPair;\r\n/**\r\n * This class provides key pair functionality for Ed25519 curve:\r\n * generating key pairs, encoding key pairs, signing and verifying.\r\n */\r\nclass KeyPairEd25519 extends KeyPair {\r\n    /**\r\n     * Construct an instance of key pair given a secret key.\r\n     * It's generally assumed that these are encoded in base58.\r\n     * @param {string} secretKey\r\n     */\r\n    constructor(secretKey) {\r\n        super();\r\n        const keyPair = tweetnacl_1.default.sign.keyPair.fromSecretKey(serialize_1.base_decode(secretKey));\r\n        this.publicKey = new PublicKey({ keyType: KeyType.ED25519, data: keyPair.publicKey });\r\n        this.secretKey = secretKey;\r\n    }\r\n    /**\r\n     * Generate a new random keypair.\r\n     * @example\r\n     * const keyRandom = KeyPair.fromRandom();\r\n     * keyRandom.publicKey\r\n     * // returns [PUBLIC_KEY]\r\n     *\r\n     * keyRandom.secretKey\r\n     * // returns [SECRET_KEY]\r\n     */\r\n    static fromRandom() {\r\n        const newKeyPair = tweetnacl_1.default.sign.keyPair();\r\n        return new KeyPairEd25519(serialize_1.base_encode(newKeyPair.secretKey));\r\n    }\r\n    sign(message) {\r\n        const signature = tweetnacl_1.default.sign.detached(message, serialize_1.base_decode(this.secretKey));\r\n        return { signature, publicKey: this.publicKey };\r\n    }\r\n    verify(message, signature) {\r\n        return tweetnacl_1.default.sign.detached.verify(message, signature, this.publicKey.data);\r\n    }\r\n    toString() {\r\n        return `ed25519:${this.secretKey}`;\r\n    }\r\n    getPublicKey() {\r\n        return this.publicKey;\r\n    }\r\n}\r\nexports.KeyPairEd25519 = KeyPairEd25519;\r\n"},"sourceMaps":{"js":{"version":3,"file":"key_pair.js","sourceRoot":"","sources":["../node_modules/near-api-js/src/utils/key_pair.ts"],"names":[],"mappings":"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","sourcesContent":["import nacl from 'tweetnacl';\nimport { base_encode, base_decode } from './serialize';\nimport { Assignable } from './enums';\n\nexport type Arrayish = string | ArrayLike<number>;\n\nexport interface Signature {\n    signature: Uint8Array;\n    publicKey: PublicKey;\n}\n\n/** All supported key types */\nexport enum KeyType {\n    ED25519 = 0,\n}\n\nfunction key_type_to_str(keyType: KeyType): string {\n    switch (keyType) {\n    case KeyType.ED25519: return 'ed25519';\n    default: throw new Error(`Unknown key type ${keyType}`);\n    }\n}\n\nfunction str_to_key_type(keyType: string): KeyType {\n    switch (keyType.toLowerCase()) {\n    case 'ed25519': return KeyType.ED25519;\n    default: throw new Error(`Unknown key type ${keyType}`);\n    }\n}\n\n/**\n * PublicKey representation that has type and bytes of the key.\n */\nexport class PublicKey extends Assignable {\n    keyType: KeyType;\n    data: Uint8Array;\n\n    static from(value: string | PublicKey): PublicKey {\n        if (typeof value === 'string') {\n            return PublicKey.fromString(value);\n        }\n        return value;\n    }\n\n    static fromString(encodedKey: string): PublicKey {\n        const parts = encodedKey.split(':');\n        if (parts.length === 1) {\n            return new PublicKey({ keyType: KeyType.ED25519, data: base_decode(parts[0]) });\n        } else if (parts.length === 2) {\n            return new PublicKey({ keyType: str_to_key_type(parts[0]), data: base_decode(parts[1]) });\n        } else {\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n        }\n    }\n\n    toString(): string {\n        return `${key_type_to_str(this.keyType)}:${base_encode(this.data)}`;\n    }\n}\n\nexport abstract class KeyPair {\n    abstract sign(message: Uint8Array): Signature;\n    abstract verify(message: Uint8Array, signature: Uint8Array): boolean;\n    abstract toString(): string;\n    abstract getPublicKey(): PublicKey;\n\n    /**\n     * @param curve Name of elliptical curve, case-insensitive\n     * @returns Random KeyPair based on the curve\n     */\n    static fromRandom(curve: string): KeyPair {\n        switch (curve.toUpperCase()) {\n        case 'ED25519': return KeyPairEd25519.fromRandom();\n        default: throw new Error(`Unknown curve ${curve}`);\n        }\n    }\n\n    static fromString(encodedKey: string): KeyPair {\n        const parts = encodedKey.split(':');\n        if (parts.length === 1) {\n            return new KeyPairEd25519(parts[0]);\n        } else if (parts.length === 2) {\n            switch (parts[0].toUpperCase()) {\n            case 'ED25519': return new KeyPairEd25519(parts[1]);\n            default: throw new Error(`Unknown curve: ${parts[0]}`);\n            }\n        } else {\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n        }\n    }\n}\n\n/**\n * This class provides key pair functionality for Ed25519 curve:\n * generating key pairs, encoding key pairs, signing and verifying.\n */\nexport class KeyPairEd25519 extends KeyPair {\n    readonly publicKey: PublicKey;\n    readonly secretKey: string;\n\n    /**\n     * Construct an instance of key pair given a secret key.\n     * It's generally assumed that these are encoded in base58.\n     * @param {string} secretKey\n     */\n    constructor(secretKey: string) {\n        super();\n        const keyPair = nacl.sign.keyPair.fromSecretKey(base_decode(secretKey));\n        this.publicKey = new PublicKey({ keyType: KeyType.ED25519, data: keyPair.publicKey });\n        this.secretKey = secretKey;\n    }\n\n    /**\n     * Generate a new random keypair.\n     * @example\n     * const keyRandom = KeyPair.fromRandom();\n     * keyRandom.publicKey\n     * // returns [PUBLIC_KEY]\n     *\n     * keyRandom.secretKey\n     * // returns [SECRET_KEY]\n     */\n    static fromRandom() {\n        const newKeyPair = nacl.sign.keyPair();\n        return new KeyPairEd25519(base_encode(newKeyPair.secretKey));\n    }\n\n    sign(message: Uint8Array): Signature {\n        const signature = nacl.sign.detached(message, base_decode(this.secretKey));\n        return { signature, publicKey: this.publicKey };\n    }\n\n    verify(message: Uint8Array, signature: Uint8Array): boolean {\n        return nacl.sign.detached.verify(message, signature, this.publicKey.data);\n    }\n\n    toString(): string {\n        return `ed25519:${this.secretKey}`;\n    }\n\n    getPublicKey(): PublicKey {\n        return this.publicKey;\n    }\n}\n"]}},"error":null,"hash":"2cce4d8840472a4a04cab2ba81e7592f","cacheData":{"env":{}}}